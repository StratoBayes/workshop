[
  {
    "objectID": "StratoBayes.html",
    "href": "StratoBayes.html",
    "title": "Day 2 - StratoBayes",
    "section": "",
    "text": "The files are hosted on the StratoBayes.github.io Github repository. Download them by following the links below, which will lead you to the Github page where the file is hosted. To start the download, click on the downward facing arrow, or click on the three dots (...) in the top right corner, and select Download.",
    "crumbs": [
      "Workshop material",
      "Day 2 - StratoBayes"
    ]
  },
  {
    "objectID": "StratoBayes.html#bayes-theorem-and-mcmc",
    "href": "StratoBayes.html#bayes-theorem-and-mcmc",
    "title": "Day 2 - StratoBayes",
    "section": "Bayes theorem and MCMC",
    "text": "Bayes theorem and MCMC\nWorksheet for the session:\nR script bvn_gibbs.R\nR script bimodal_walker.R",
    "crumbs": [
      "Workshop material",
      "Day 2 - StratoBayes"
    ]
  },
  {
    "objectID": "StratoBayes.html#stratobayes-tutorial",
    "href": "StratoBayes.html#stratobayes-tutorial",
    "title": "Day 2 - StratoBayes",
    "section": "StratoBayes tutorial",
    "text": "StratoBayes tutorial\nWorkshop participants can install the workshop version of StratoBayes by running:\ninstall.packages(\"StratoBayes\", repos = c(getOption(\"repos\"), \"https://ms609.github.io/packages\"))\nR version 4.3 or above is required.\nThe Zip folder that contains the data and worksheets for the tutorial can be downloaded here: StratoBayes Tutorial\nExtract the files in a folder and set your R working directory to that folder using the setwd function. The worksheets are called StratoBayes_1_Correlation.html and StratoBayes_2_AgeModel.html. There are corresponding StratoBayes_1_Correlation.qmd and StratoBayes_2_AgeModel.qmd files that you can open with R.\nIf you have StratoBayes and the dependencies installed, you should be able to run the code blocks by clicking the green arrows in the .qmd files. You will need to run them in order, i.e. code blocks further down the document may not run if you haven’t run the previous code blocks. When you are working within these .qmd files, your working directory will be the folder where the .qmd file is saved.\nAlternatively, you can copy the code blocks from the worksheets or the .qmd to your own R script. Beware that you may have to adapt the file paths or working directory.",
    "crumbs": [
      "Workshop material",
      "Day 2 - StratoBayes"
    ]
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "Time\nActivity\n\n\n\n\n09:00-10:30\nIntroduction to R and RStudio\n\n\n10:30-11:00\nCoffee Break\n\n\n11:00-12:30\nHandling data: import and manipulation\n\n\n12:30-13:30\nLunch Break\n\n\n13:30-15:00\nVisualising and describing data\n\n\n15:00-15:30\nCoffee Break\n\n\n15:30-17:00\nWriting functions\n\n\n17:00-18:30\nIcebreaker\n\n\n19:00\nDinner",
    "crumbs": [
      "Overview",
      "Schedule"
    ]
  },
  {
    "objectID": "schedule.html#day-1-introduction-to-r-18th-march-optional",
    "href": "schedule.html#day-1-introduction-to-r-18th-march-optional",
    "title": "Schedule",
    "section": "",
    "text": "Time\nActivity\n\n\n\n\n09:00-10:30\nIntroduction to R and RStudio\n\n\n10:30-11:00\nCoffee Break\n\n\n11:00-12:30\nHandling data: import and manipulation\n\n\n12:30-13:30\nLunch Break\n\n\n13:30-15:00\nVisualising and describing data\n\n\n15:00-15:30\nCoffee Break\n\n\n15:30-17:00\nWriting functions\n\n\n17:00-18:30\nIcebreaker\n\n\n19:00\nDinner",
    "crumbs": [
      "Overview",
      "Schedule"
    ]
  },
  {
    "objectID": "schedule.html#day-2-stratobayes-correlation-and-age-modelling-19th-march",
    "href": "schedule.html#day-2-stratobayes-correlation-and-age-modelling-19th-march",
    "title": "Schedule",
    "section": "Day 2 – StratoBayes: Correlation and age modelling – 19th March",
    "text": "Day 2 – StratoBayes: Correlation and age modelling – 19th March\n\n\n\nTime\nActivity\n\n\n\n\n09:00-09:15\nWelcome and introductions\n\n\n09:15-09:45\nBackground on StratoBayes\n\n\n09:45-10:45\nBayes theorem and MCMC\n\n\n10:45-11:15\nCoffee Break\n\n\n11:15-12:30\nStratigraphic correlation and age modelling\n\n\n12:30-13:30\nLunch Break\n\n\n13:30-15:30\nCorrelation with the StratoBayes R package\n\n\n15:00-15:30\nCoffee Break\n\n\n15:30-17:30\nAge modelling with the StratoBayes R package",
    "crumbs": [
      "Overview",
      "Schedule"
    ]
  },
  {
    "objectID": "schedule.html#day-3-delegate-project-work-20th-march",
    "href": "schedule.html#day-3-delegate-project-work-20th-march",
    "title": "Schedule",
    "section": "Day 3 – Delegate project work – 20th March",
    "text": "Day 3 – Delegate project work – 20th March\n\n\n\nTime\nActivity\n\n\n\n\n09:00-09:45\nParticipants introduce their projects\n\n\n09:45-10:30\nIndividual project work\n\n\n10:30-11:00\nCoffee break\n\n\n10:30-12:30\nIndividual project work\n\n\n12:30-13:30\nLunch Break\n\n\n13:30-13:45\nQuick updates on progress\n\n\n13:45-15:00\nIndividual project work\n\n\n15:00-15:30\nCoffee Break\n\n\n15:30-16:30\nFinalising individual project work\n\n\n16:30-17:30\nPresenting & discussing results",
    "crumbs": [
      "Overview",
      "Schedule"
    ]
  },
  {
    "objectID": "leisure.html",
    "href": "leisure.html",
    "title": "Leisure",
    "section": "",
    "text": "Durham is famous for its mighty cathedral, which forms part of the Durham Castle and Cathedral World Heritage Site. The cathedral can be visited throughout the day, and the cathedral tower (booking required) offers a spectacular view. The historic city centre with its picturesque bridges and forested riverbanks invites for a stroll. Durham University is home to 20,000 students, contributing to a lively ambiance in the town’s many bars and cafes.",
    "crumbs": [
      "Leisure"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "StratoBayes workshop",
    "section": "",
    "text": "18th – 20th March 2024, Durham, UK",
    "crumbs": [
      "Overview",
      "StratoBayes workshop"
    ]
  },
  {
    "objectID": "index.html#about",
    "href": "index.html#about",
    "title": "StratoBayes workshop",
    "section": "About",
    "text": "About\nWelcome to the StratoBayes workshop. Stratigraphic correlation and age modelling are fundamental for understanding Earth history, the evolution of life and climate, as well as for the extraction of subsurface resources. The StratoBayes R package takes a Bayesian approach to correlating and dating geological data. It automatically aligns geochemical or geophysical signals measured in multiple outcrops or wells, and is able to integrate absolute age constraints such as radiometric dates, providing age-depth models with realistic uncertainty estimates. In this workshop, participants will learn the use of the StratoBayes R package, and are encouraged to build stratigraphic correlations or age models using their own data sets. The workshop includes an optional introduction to R on day one, followed by two days of working with stratigraphic data.",
    "crumbs": [
      "Overview",
      "StratoBayes workshop"
    ]
  },
  {
    "objectID": "index.html#requirements",
    "href": "index.html#requirements",
    "title": "StratoBayes workshop",
    "section": "Requirements",
    "text": "Requirements\nThis event is open to anyone with an interest in stratigraphic correlation or age modelling. No knowledge of R is required, but participants without prior experience with R should join the introduction to R on day one of the workshop. Participants need to bring a laptop or similar device. Participants are encouraged to bring their own stratigraphic data sets, which will be used on day three. We will have alternative data sets for participants who don’t have stratigraphic data of their own.",
    "crumbs": [
      "Overview",
      "StratoBayes workshop"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "StratoBayes workshop",
    "section": "Installation",
    "text": "Installation\nR and Rstudio need to be installed on the participants’ laptops.\nIt would be helpful to install necessary packages by typing the following command into the R console:\ninstall.packages(c(\n  \"cli\", \"coda\", \"doParallel\", \"EnvStats\", \"fda\", \"foreach\",\n  \"dbscan\", \"mcmcse\", \"msm\", \"mvnfast\", \"protoclust\", \"Rcpp\",\n  \"RcppEigen\", \"Rdpack\", \"Rfast\"))",
    "crumbs": [
      "Overview",
      "StratoBayes workshop"
    ]
  },
  {
    "objectID": "food-and-drinks.html",
    "href": "food-and-drinks.html",
    "title": "Catering",
    "section": "",
    "text": "There will be a coffee break in the morning and in the afternoon, during which coffee and tea will be served. Sandwiches will be served during lunch break.\nThe Icebreaker at 5pm on 18th March at St. John’s college is included for all participants.",
    "crumbs": [
      "Logistics",
      "Catering"
    ]
  },
  {
    "objectID": "Day3.html",
    "href": "Day3.html",
    "title": "Day 3 - Working with your own datasets",
    "section": "",
    "text": "If you don’t have a dataset you would like to work with, you can use a carbon isotope data set with radiometric dates from Morocco and Siberia. The spreadsheets and the papers from which the data were taken are in the Zip folder:\nMorocco_Siberia\nSome approaches you could try:\n\nStart by correlating just two sections on the height scale\nYou could also start with correlating just some parts of sections, discarding the rest of the data\nSimplify the lithology data - does it make sense to assume that the same lithology at the bottom and top of a long section had the same sedimentation rate, or do you want to split the data differently?\nAre there any unconformities? For example, add a gap at the sequence boundary between the Sukharika and Krasnoporog formations in the Siberian section\nTry a correlation on the age scale, using the radiometric ages",
    "crumbs": [
      "Workshop material",
      "Day 3 - Working with your own datasets"
    ]
  },
  {
    "objectID": "accommodation.html",
    "href": "accommodation.html",
    "title": "Accommodation",
    "section": "",
    "text": "Accommodation\nThe closest accommodation can be found at St Chad’s college, a 3-minute walk from the workshop site. Single en-suite rooms are £69.50 per night, single rooms with access to a shared are £57 per night. Please contact St Chad’s college at +44 191 334 3358 or chads@durham.ac.uk for room booking. Rooms are available from 17th March.\nNearby hotels include the Travelodge, Premier Inn and Delta Hotels Durham Royal County."
  },
  {
    "objectID": "files/Session-4-Functions/index.html#what-is-a-function",
    "href": "files/Session-4-Functions/index.html#what-is-a-function",
    "title": "Writing functions in R",
    "section": "What is a function",
    "text": "What is a function\ntakes input –&gt; does something –&gt; returns output\n\n\nmean(c(1, 2, 3))\n\n[1] 2\n\n\n\n\n\nA function needs a name, arguments in (), and a body in {}\n\nsubtract &lt;- function(arg1, arg2) { \n  arg1 - arg2 \n} \n\n\n\n\n\nsubtract(2, 1)\n\n[1] 1"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#why-do-we-need-functions",
    "href": "files/Session-4-Functions/index.html#why-do-we-need-functions",
    "title": "Writing functions in R",
    "section": "Why do we need functions",
    "text": "Why do we need functions\n\n\n\nReadability\nOrganisation\n\n\n\nModularity\nReusability\n\n\n\n\nImagine calculating the mean without standard functions like mean or sum:\n\n\n\n  data &lt;- c(1,2,3)\n  total &lt;- 0\n  count &lt;- 0\n  for (value in data) {\n    total &lt;- total + value\n    count &lt;- count + 1\n  }\n  total/count\n\n[1] 2"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#arguments",
    "href": "files/Session-4-Functions/index.html#arguments",
    "title": "Writing functions in R",
    "section": "Arguments",
    "text": "Arguments\nArguments need to be provided in the correct order, or specified by name: \n\n\nsubtract(2, 1)\n\n[1] 1\n\n\n\n\n\n\nsubtract(1, 2)\n\n[1] -1\n\n\n\n\n\n\nsubtract(arg2 = 1, arg1 = 2)\n\n[1] 1"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#default-values",
    "href": "files/Session-4-Functions/index.html#default-values",
    "title": "Writing functions in R",
    "section": "Default values",
    "text": "Default values\nMake function use more convenient, can hide complexities.\n\n\nsubtract(2)\n\nError in subtract(2): argument \"arg2\" is missing, with no default\n\n\n\n\n\nThis will work if we set a default for arg2:\n\nsubtract &lt;- function(arg1, arg2 = 1) {\n  arg1 - arg2\n}\n\n\n\n\n\nsubtract(2)\n\n[1] 1"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#ellipsis",
    "href": "files/Session-4-Functions/index.html#ellipsis",
    "title": "Writing functions in R",
    "section": "Ellipsis (‘…’)",
    "text": "Ellipsis (‘…’)\nAdditional, optional arguments can be allowed by using ‘…’ as the last argument:\n\n\nmy_plot &lt;- function(arg1, arg2, ...) {\n  plot(arg1, arg2, ...)\n}\n\n\n\n\n\nmy_plot(2, 1, col = \"red\", pch = 17, cex = 2)"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#return",
    "href": "files/Session-4-Functions/index.html#return",
    "title": "Writing functions in R",
    "section": "Return",
    "text": "Return\nA function generally should return something, but this does not:\n\n\nsubtract &lt;- function(arg1, arg2) {\n  result &lt;- arg1 - arg2\n}\n\n\n\n\nsubtract(2,1)\n\n\n\n\nReturn explicitly with return, or place return value at the end of the function:\n\nsubtract &lt;- function(arg1, arg2) {\n  result &lt;- arg1 - arg2\n  return(result)\n}\n\n\n\n\nsubtract(2,1)\n\n[1] 1"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#return-multiple-objects",
    "href": "files/Session-4-Functions/index.html#return-multiple-objects",
    "title": "Writing functions in R",
    "section": "Return multiple objects",
    "text": "Return multiple objects\n\n\njust_return &lt;- function(arg1, arg2) {\nreturn(arg1)\nreturn(arg2)\n}\n\n\n\n\njust_return(2, 1)\n\n[1] 2\n\n\nThis did not work as intended. R functions only return one object. Instead use lists or other data structures:\n\n\n\njust_return &lt;- function(arg1, arg2) {\nreturn(c(arg1, arg2))\n}\n\n\n\n\njust_return(2, 1)\n\n[1] 2 1"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#exercise-1a---building-a-function",
    "href": "files/Session-4-Functions/index.html#exercise-1a---building-a-function",
    "title": "Writing functions in R",
    "section": "Exercise 1a - Building a function",
    "text": "Exercise 1a - Building a function\nWrite a function that adds two values and creates a scatter plot with first value on the x-axis and the result on the y axis.\nHint\n\n\nClick to expand/collapse\n\nFirst, we add the two values and save it in an object within the function. Then, we use the plot function to create a scatter plot with x being the first value, and y being the object we created with the addtion.\n\nSolution\n\n\nClick to expand/collapse\n\n\nadd_and_plot &lt;- function(a, b) {\n  result &lt;- a + b\n  plot(a, result)\n}"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#exercise-1b---expanding-a-function",
    "href": "files/Session-4-Functions/index.html#exercise-1b---expanding-a-function",
    "title": "Writing functions in R",
    "section": "Exercise 1b - Expanding a function",
    "text": "Exercise 1b - Expanding a function\nExpand the function you just created to let it return the result after plotting\nHint\n\n\nClick to expand/collapse\n\nWe can place the object we want to return at the end of our function, or use the return function.\n\nSolution\n\n\nClick to expand/collapse\n\n\nadd_and_plot &lt;- function(a, b) {\n  result &lt;- a + b\n  plot(a, result)\n  result\n}"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#exercise-1c---passing-additional-arguments",
    "href": "files/Session-4-Functions/index.html#exercise-1c---passing-additional-arguments",
    "title": "Writing functions in R",
    "section": "Exercise 1c - Passing additional arguments",
    "text": "Exercise 1c - Passing additional arguments\nExpand the function further by allowing customisation of the plot by changing graphical parameters.\nHint\n\n\nClick to expand/collapse\n\nWe can use ellipsis (...) as a function argument in the outer and the inner function to allow for additional arguments being passed.\n\nSolution\n\n\nClick to expand/collapse\n\n\nadd_and_plot &lt;- function(a, b, ...) {\n  result &lt;- a + b\n  plot(a, result, ...)\n  result\n}"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#binary-operators-1",
    "href": "files/Session-4-Functions/index.html#binary-operators-1",
    "title": "Writing functions in R",
    "section": "Binary operators",
    "text": "Binary operators\n\n\n\nStandard function syntax:\n\nsum(c(1,2))\n\n[1] 3\n\n\n\n\n\nOperator syntax:\n\n1 + 2\n\n[1] 3\n\n\n\n\n\n\n\n\nMost binary operators come in %:\n\n\n\n\n3 %in% c(1,2,3)\n\n[1] TRUE\n\n\n\n\n\n\n\nCustom binary operators – let’s define an operator for “not in”:\n\n`%!in%` &lt;- function(x, y) !(x %in% y)\n\n\n\n\n3 %!in% c(1,2,3)\n\n[1] FALSE"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#control-structures-if",
    "href": "files/Session-4-Functions/index.html#control-structures-if",
    "title": "Writing functions in R",
    "section": "Control structures – if",
    "text": "Control structures – if\nif a condition is true, do something.\n\n\nif (1 + 1 == 2) print(\"True\")\n\n[1] \"True\"\n\n\n\n\n\n\nadd_or_subtract &lt;- function(arg1, arg2, operation) {\n if (operation == \"add\") {\n   result &lt;- arg1 + arg2\n }\n if (operation == \"subtract\") {\n   result &lt;- arg1 + arg2\n }\n result\n}\n\n\n\n\nadd_or_subtract(2,1,\"add\")\n\n[1] 3"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#control-structures-else",
    "href": "files/Session-4-Functions/index.html#control-structures-else",
    "title": "Writing functions in R",
    "section": "Control structures – else",
    "text": "Control structures – else\nelse instructs what to do when the if condition is not met.\n\n\nif (1 + 1 == 3) print(\"True\") else print(\"False\")\n\n[1] \"False\"\n\n\n\n\n\n\nadd_or_subtract &lt;- function(arg1, arg2, operation) {\n if (operation == \"add\") {\n   result &lt;- arg1 + arg2\n } else {\n   result &lt;- arg1 - arg2\n }\n return(result)\n}\n\n\n\n\nadd_or_subtract(2,1,\"subtract\")\n\n[1] 1"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#control-structures-switch",
    "href": "files/Session-4-Functions/index.html#control-structures-switch",
    "title": "Writing functions in R",
    "section": "Control structures – switch",
    "text": "Control structures – switch\nInstead of many if and else statements, try switch\n\n\nfossil_description &lt;- function(fossil) {\n switch(fossil,\n  ammonite = \"coiled shell\",\n  Tyrannosaurus = \"serrated teeth\",\n  Lepidodendron = \"scaly bark\", \n  \"not a fossil\"\n )\n}\n\n\n\n\nfossil_description(\"Tyrannosaurus\")\n\n[1] \"serrated teeth\"\n\n\n\n\n\nfossil_description(\"laptop\")\n\n[1] \"not a fossil\""
  },
  {
    "objectID": "files/Session-4-Functions/index.html#control-structures-for-loops",
    "href": "files/Session-4-Functions/index.html#control-structures-for-loops",
    "title": "Writing functions in R",
    "section": "Control structures – for loops",
    "text": "Control structures – for loops\nLoops are used for repeating similar actions multiple times. for loops iterate over a set of values. The iterator (i) changes with every iteration of the loop:\n\n\nfor (i in c(1,2,3)) print(i)\n\n[1] 1\n[1] 2\n[1] 3\n\n\n\n\nTo generate sequences of integers, we can use seq_len. Let’s make a function:\n\nprint_repetitions &lt;- function(n) {\n for (i in seq_len(n)) { \n   print(i)\n }\n}\n\n\n\n\nprint_repetitions(2)\n\n[1] 1\n[1] 2"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#control-structures-while-loops",
    "href": "files/Session-4-Functions/index.html#control-structures-while-loops",
    "title": "Writing functions in R",
    "section": "Control structures – while loops",
    "text": "Control structures – while loops\nwhile loops repeat a task until a condition is no longer met.\n\n\nadd_until_4 &lt;- function(x) {\n  while(x &lt; 4) {\n    x &lt;- x + 1\n    print(x)\n  }\n}\n\n\n\n\nadd_until_4(1)\n\n[1] 2\n[1] 3\n[1] 4"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#exercise-2a---building-a-loop",
    "href": "files/Session-4-Functions/index.html#exercise-2a---building-a-loop",
    "title": "Writing functions in R",
    "section": "Exercise 2a - Building a loop",
    "text": "Exercise 2a - Building a loop\nCreate a for loop that calculates the mean of all numerical columns of the Talat_isotopes dataset. If the dataset is not already loaded, we can read it with:\n\n# read the \"Talat_n_Yissi_isotopes.csv\" from session 3:\nTalat_isotopes &lt;- read.csv(\"data/Talat_n_Yissi_isotopes.csv\", \n                           header = TRUE)\n\nHint 1\n\n\nClick to expand/collapse\n\nTo check if a column is numeric, we can use is.numeric on the column. Using if and possibly else allows us to do different operations depending on the outcome of is.numeric.\nSelecting a column can be done with square brackets, e.g. Talat_isotopes[ ,1] selects the first column.\nTo get the number of columns of Talat_isotopes, we can use the ncol function.\n\nHint 2\n\n\nClick to expand/collapse\n\nStart a loop for example with for (i in seq_len(ncol(Talat_isotopes))) { } to run it for one iteration per number of columns. Everything inside the curly brackets is done exactly the same in each iteration, except i changes. To print the output at every iteration of the function, we can use the print function.\n\nSolution\n\n\nClick to expand/collapse\n\n\n# save number of columns\nnCol &lt;- ncol(Talat_isotopes)\n# run loop for nCol iterations\nfor (i in seq_len(nCol)) {\n  if(is.numeric(Talat_isotopes[,i])) {\n    print(mean(Talat_isotopes[,i]))\n  }\n}\n\n[1] -0.335762\n[1] -10.78194\n[1] 411.5718\n[1] 519.5261\n[1] 205.5268"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#exercise-2b---turn-the-loop-into-a-function",
    "href": "files/Session-4-Functions/index.html#exercise-2b---turn-the-loop-into-a-function",
    "title": "Writing functions in R",
    "section": "Exercise 2b - Turn the loop into a function",
    "text": "Exercise 2b - Turn the loop into a function\nFrom the loop created in exercise 1, create a function that takes the Talat_isotopes dataframe (or any other dataframe) as input and returns the means of numerical columns as output.\nHint\n\n\nClick to expand/collapse\n\nWe can return the output by saving the result of every iteration of the loop in an object, and then return that object. We can omit NA output by indexing with !is.na.\n\nSolution\n\n\nClick to expand/collapse\n\n\nnumericColumnMean &lt;- function(df) {\n  # save number of columns\n  nCol &lt;- ncol(df)\n  # create a vector for the output\n  output &lt;- rep(NA,nCol)\n  # run loop for nCol iterations\n  for (i in seq_len(nCol)) {\n    if(is.numeric(df[,i])) {\n      output[i] &lt;- mean(df[,i])\n    } else {  # NA for non-numeric columns:\n      output[i] &lt;- NA \n      }\n  }\n  # return output that is not NA\n  output[!is.na(output)]\n}\n# apply function\nnumericColumnMean(Talat_isotopes)\n\n[1]  -0.335762 -10.781942 411.571816 519.526138 205.526785"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#apply",
    "href": "files/Session-4-Functions/index.html#apply",
    "title": "Writing functions in R",
    "section": "apply",
    "text": "apply\n\napply and related functions apply a function to elements of arrays, lists, …\nmore concise than loops and don’t change global environment\n\n\nFor example, to get the classes of the first three columns of the Talat_isotopes data:\n\nTalat_classes &lt;- rep(NA,3)\nfor (i in 1:3) {\n  Talat_classes[i] &lt;- class(Talat_isotopes[,i])\n}\nTalat_classes\n\n[1] \"character\" \"numeric\"   \"numeric\"  \n\n\n\n\nOr with apply:\n\napply(Talat_isotopes[,1:3], MARGIN = 2, FUN = class)\n\n     sample        d13C        d18O \n\"character\" \"character\" \"character\""
  },
  {
    "objectID": "files/Session-4-Functions/index.html#apply-1",
    "href": "files/Session-4-Functions/index.html#apply-1",
    "title": "Writing functions in R",
    "section": "apply",
    "text": "apply\nLet’s have a look what happened there. apply(X, MARGIN, FUN) takes an array X (our Talat_isotopes dataframe), and applies a function (FUN) to elements of that array, specified by MARGIN.\n\n\n\n\nMARGIN = 2 indicates columns, MARGIN = 1 would be rows. So here we applied the class function to every column of Talat_isotopes.\n\n\n\napply simplifies the output, so here it returned a vector with one element for each column."
  },
  {
    "objectID": "files/Session-4-Functions/index.html#lapply",
    "href": "files/Session-4-Functions/index.html#lapply",
    "title": "Writing functions in R",
    "section": "lapply",
    "text": "lapply\nlapply is similar to apply but for list or vector input. It returns a list for each element of the data.\n\n\ndata &lt;- list(c(1, 2, 3), c(4, 5))\nlapply(data, mean)\n\n[[1]]\n[1] 2\n\n[[2]]\n[1] 4.5\n\n\n\n\n\n\n\nsapply does the same, but also tries to simplify the output; here we get a vector:\n\ndata &lt;- list(c(1, 2, 3), c(4, 5))\nsapply(data, mean)\n\n[1] 2.0 4.5"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#vapply",
    "href": "files/Session-4-Functions/index.html#vapply",
    "title": "Writing functions in R",
    "section": "vapply",
    "text": "vapply\nvapply is a safer version of sapply, it requires the user to specify the anticipated class and length of the elements of the output:\n\n\n\n\n\ndata &lt;- list(c(1, 2, 3), c(4, 5))\nvapply(data, FUN = mean, FUN.VALUE = numeric(1))\n\n[1] 2.0 4.5\n\n\n\n\n\nHere, we specified in FUN.VALUE that each element of the output should be a numeric of length 1."
  },
  {
    "objectID": "files/Session-4-Functions/index.html#exercise-3a---use-apply-to-calculate-column-means",
    "href": "files/Session-4-Functions/index.html#exercise-3a---use-apply-to-calculate-column-means",
    "title": "Writing functions in R",
    "section": "Exercise 3a - Use apply to calculate column means",
    "text": "Exercise 3a - Use apply to calculate column means\nIn exercise 2, we built a function that calculated the mean of all numerical columns of the Talat_isotopes dataset and returned it.\nCan we achieve the same using apply?\nThis task is trickier than it looks like as apply coerces all columns to type character as soon as there is even one character column. We can add as.numeric to try and force columns into numeric. Better yet, we just select the columns containing values that can be coerced to be numeric:\n\nnumeric_columns &lt;- c(\"d18O\", \"d13C\", \"m\", \"age\", \"m.my\")\nTalat_numeric &lt;- Talat_isotopes[ ,numeric_columns]\n\nHint 1\n\n\nClick to expand/collapse\n\nThe second argument of apply, MAR, needs to be set to 2 for columnwise operations.\nIn the third argument, we can define a function, for example function(col) { } will modify each column according to the instructions in curly brackets, refering to the column as col.\n\nSolution\n\n\nClick to expand/collapse\n\n\napply(Talat_numeric, 2, function (col) {\n  mean(col)\n  }\n)\n\n      d18O       d13C          m        age       m.my \n-10.781942  -0.335762 411.571816 519.526138 205.526785 \n\n\nOr simply:\n\napply(Talat_numeric, 2, mean)\n\n      d18O       d13C          m        age       m.my \n-10.781942  -0.335762 411.571816 519.526138 205.526785"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#exercise-3b---reading-a-messy-dataset",
    "href": "files/Session-4-Functions/index.html#exercise-3b---reading-a-messy-dataset",
    "title": "Writing functions in R",
    "section": "Exercise 3b - Reading a messy dataset",
    "text": "Exercise 3b - Reading a messy dataset\nThe Talat_isotopes and Talat_elements datasets are contained in a mulit-sheet Excel file from the supplementary materials Maloof et al. (2010). It is in the data folder and named Maloof_et_al_2010_SM.xls.\nReading such files with R can be a challenge and it is often easier to copy-paste the relevant data into clean spreadsheets and save them as .csv files.\nHowever, here we try to automate the reading of sheets from this particular file, starting from the sheet Morocco-Talat n’ Yissi`.\nWe start by installing and loading the readxl package.\n\n# Install and load the readxl package if you haven't already\nif (!require(readxl)) install.packages(\"readxl\")\nlibrary(readxl)\n\nWe notice that the Morocco-Talat n' Yissi sheet has two header rows, and the formatting is messy.\nWe read in the header rows of the sheet 4. Morocco-Talat n' Yissi:\n\n# specify the file path\nfile_path &lt;- \"data/Maloof_et_al_2010_SM.xls\"\n# specify the sheet name\nsheet_name &lt;- \"4. Morocco-Talat n' Yissi\"\n# read the top two rows\n# trim_ws stops omitting empty cells\n# col_names = FALSE stops cells being used as column names\nheader_rows &lt;- read_excel(file_path, sheet = sheet_name, n_max = 2,\n                          trim_ws = FALSE, col_names = FALSE)\n\nNext, we merge the header rows as we want only a single column name per column:\n\ncolumn_names &lt;- apply(header_rows, 2, function(x) paste(na.omit(x), collapse = \"_\"))\n\nFinally, we use these column names for reading the entire data set, skipping the first two problematic rows:\n\ntalat &lt;- read_excel(file_path, sheet = sheet_name, skip = 2, col_names = column_names)\n\nThe result looks reasonable:\n\nhead(talat[ ,c(1:4)])\n\n# A tibble: 6 × 4\n  `0_sample`  d13C   d18O d13Corg\n  &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt;  \n1 M250-2.1   -2.07  -7.95 NA     \n2 M250-2.6   -1.78 -10.7  NA     \n3 M250-3.6   -2.04 -10.9  NA     \n4 M250-4.4   -2.34  -9.53 NA     \n5 M250-6.1   -2.04  -8.92 NA     \n6 M250-7.5   -1.59  -6.84 NA     \n\n\nExercise: Can you build a function from the above and apply it to other sheets of the Maloof_et_al_2010_SM.xls file? We can also build a second function that uses this function to read multiple sheets at once.\nHint\n\n\nClick to expand/collapse\n\nWe can almost copy-paste the lines we used to read the sheet earlier and collate them in a function.\nWe need two arguments: the file_path, and the sheet_index.\nlapply is useful if we want to use that function on multiple sheets at once.\n\nSolution\n\n\nClick to expand/collapse\n\nHere is a function that reads a single sheet:\n\nread_sheets_Maloof &lt;- function(file_path, sheet_index) {\n  # read the top two rows\n  header_rows &lt;- read_excel(file_path, sheet = sheet_index, n_max = 2,\n                            trim_ws = FALSE, col_names = FALSE)\n  # merge to column names\n  column_names &lt;- apply(header_rows, 2, function(x) {\n    paste(na.omit(x), collapse = \"_\")\n  })\n  # read the rest of the file\n  output &lt;- read_excel(file_path, sheet = sheet_index, \n                       skip = 2, col_names = column_names)\n  output\n}\n\nUsing lapply, we can build a simple function that uses the previous function to read multiple sheets at once and saves them as a list of dataframes. Here, we use the indices of the sheets, rather than the names, so we don’t have to type out the complicated sheet names.\n\nmulti_sheets_Maloof &lt;- function(file_path, sheet_index, \n                                read_function) {\n  # do this for every sheet index (integers)\n  lapply(sheet_index, function(s) {\n    read_function(file_path = file_path, sheet_index = s)\n  })\n}\n\nFrom here, you could try to combine the dataframes e.g. using merge."
  },
  {
    "objectID": "files/Session-4-Functions/index.html#environment",
    "href": "files/Session-4-Functions/index.html#environment",
    "title": "Writing functions in R",
    "section": "Environment",
    "text": "Environment\nEnvironment can be conceptualised as a place where objects with a name and value exist.\n\nFor example, when we run\n\nx &lt;- 1\n\nx now exists in the global environment, and has the value 1.\n\n\n\nEach function, for loop, …, creates its own environment."
  },
  {
    "objectID": "files/Session-4-Functions/index.html#environment-1",
    "href": "files/Session-4-Functions/index.html#environment-1",
    "title": "Writing functions in R",
    "section": "Environment",
    "text": "Environment\nIf we run the following function to assign to b the value of a\n\na_to_b &lt;- function(a) b &lt;- a\na_to_b(a = 1)\n\n\nand then look for b in the global environment\n\n\n\nb\n\nError in eval(expr, envir, enclos): object 'b' not found\n\n\nwe get an error because b only existed within the function environment.\n\n\n\nMore on environments: adv-r.hadley.nz/environments.html"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#scoping",
    "href": "files/Session-4-Functions/index.html#scoping",
    "title": "Writing functions in R",
    "section": "Scoping",
    "text": "Scoping\nR uses scoping rules to look for variables (or functions). If a variable is not found in a function environment, R looks in the parent environment (i.e. the environment in which the function was created).\n\n\nx &lt;- 1\ndouble_x &lt;- function(y) 2 * x + y\ndouble_x(0)\n\n[1] 2\n\n\n\n\nx is a free variable in the double_x function – it is not supplied to or defined in the function. Instead, it’s looked up in the environment where double_x was created, the global environment.\n\n\n\nThis can get tricky, see here for more details: bookdown.org/rdpeng/rprogdatascience/scoping-rules-of-r.html"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#exercise-4---use-vapply-to-return-the-three-highest-d13c-values-for-every-stage-in-talat_isotopes",
    "href": "files/Session-4-Functions/index.html#exercise-4---use-vapply-to-return-the-three-highest-d13c-values-for-every-stage-in-talat_isotopes",
    "title": "Writing functions in R",
    "section": "Exercise 4 - Use vapply to return the three highest d13C values for every stage in Talat_isotopes",
    "text": "Exercise 4 - Use vapply to return the three highest d13C values for every stage in Talat_isotopes\nAs a starting point, extract the unique stage names from the Talat_isotopes dataframe using the unique function:\n\nunique_stages &lt;- unique(Talat_isotopes$stage)\n\nHint\n\n\nClick to expand/collapse\n\nWe can use this as our first argument to vapply, and use subset to select only the values of d13C that are from a specific stage.\nThe sort function can be useful to sort the d13C values in decreasing order, for example:\n\n# function to return three largest elements of a vector\nthree_largest &lt;- function(x) {\n  # sort vector in decreasing order\n  x &lt;- sort(x, decreasing = TRUE)\n  # return the first three values\n  x[1:3]\n}\n\nInstead of passing Talat_isotopes as an argument, we can let it look up in the global environment, where it was defined.\nThe third argument of vapply needs to specify the class and length of the output. In our case, it will be three numeric values: numeric(3)\n\nSolution\n\n\nClick to expand/collapse\n\nThe first solution takes advantage of R functions being able to find variables that were defined outside the function environment:\n\n# build a custom function for vapply\nthree_largest_stages &lt;- function(s) {\n  # subset to only include rows from the current stage\n  # note: we haven't passed Talat_isotopes as a function argument\n  Talat_isotopes &lt;- subset(Talat_isotopes, stage == s)\n  # extract three largest values\n  three_largest(Talat_isotopes$d13C)\n}\n# put everything together\nvapply(unique_stages, FUN = three_largest_stages, \n       FUN.VALUE = numeric(3))\n\n        T    A    B\n[1,] 0.74 3.46 1.79\n[2,] 0.37 3.44 1.78\n[3,] 0.34 3.43 1.76\n\n\nvapply has returned the output as a matrix.\nThe function above works because Talat_isotopes is accessed from the global environment, but only modified within the function environment.\nCaution: This can lead to confusion and it is often better to avoid this.\nA cleaner solution would be to pass Talat_isotopes as a second argument to the three_largest_stages function."
  },
  {
    "objectID": "files/Session-4-Functions/index.html#error-handling",
    "href": "files/Session-4-Functions/index.html#error-handling",
    "title": "Writing functions in R",
    "section": "Error handling",
    "text": "Error handling\nVery helpful in complex functions\n\n\nsubtract(2, 1)\n\n[1] 1\n\n\n\n\n\nsubtract(\"2\", 1)\n\nError in arg1 - arg2: non-numeric argument to binary operator\n\n\n\n\n\n\n\nCheck that input is correct and display custom error messages:\n\nsubtract &lt;- function(arg1, arg2) {\n  if (is.numeric(arg1) == FALSE) {\n    stop(\"`arg1` must be numeric\") \n    }\n  arg1 - arg2\n}\n\n\n\n\nsubtract(\"2\", 1)\n\nError in subtract(\"2\", 1): `arg1` must be numeric"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#trycatch",
    "href": "files/Session-4-Functions/index.html#trycatch",
    "title": "Writing functions in R",
    "section": "tryCatch",
    "text": "tryCatch\nUse if you anticipate an error but want function to continue.\n\n\n\n\nLet’s try to generate data from a multivariate normal distribution:\n\nmvnfast::rmvn(1, mu = c(0,0), sigma = matrix(rep(1,4), 2))\n\nError in eval(expr, envir, enclos): chol(): decomposition failed\n\n\n\n\n\n\n\nmvnfast::rmvn is fast but fails for some problematic sigma values. In case it fails, we use MASS::mvrnorm instead:\n\nmy_rmvn &lt;- function(n, mu, sigma) {\n  tryCatch(mvnfast::rmvn(n, mu, sigma),\n           error = function(e) MASS::mvrnorm(n, mu, sigma))\n}\n\n\n\n\nmy_rmvn(n = 1, mu = c(0,0), sigma = matrix(rep(1,4), 2))\n\n[1] -0.09196503 -0.09196503"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#traceback",
    "href": "files/Session-4-Functions/index.html#traceback",
    "title": "Writing functions in R",
    "section": "Traceback",
    "text": "Traceback\nIf something went wrong, find out where using traceback():\n\n\nmy_rmvn(n = 1, mu = 0, sigma = matrix(rep(1,4), 2))\n\nError in MASS::mvrnorm(n, mu, sigma): incompatible arguments\n\n\n\n\n\n\n\n\ntraceback()"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#break-points",
    "href": "files/Session-4-Functions/index.html#break-points",
    "title": "Writing functions in R",
    "section": "Break points",
    "text": "Break points\nBreak points allow you to look inside your function’s environment. This works best when the function is in a separate script. Click next to a line of code in your function to activate a break point (a red dot appears):\n\n\n\n\nNow run the function…\n\nmy_rmvn(n = 1, mu = c(0,0), sigma = matrix(rep(1,4), 2))\n\n\n\nYou may need to save the script and source it (press source in the Rstudio toolbar)"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#break-points-1",
    "href": "files/Session-4-Functions/index.html#break-points-1",
    "title": "Writing functions in R",
    "section": "Break points",
    "text": "Break points"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#break-points-2",
    "href": "files/Session-4-Functions/index.html#break-points-2",
    "title": "Writing functions in R",
    "section": "Break points",
    "text": "Break points\nWe can now browse the function environment in the console like we normally can browse the global environment. For example we can look at sigma:\n\nPress Stop to end the browsing. Don’t forget to deactivate the break point by clicking on the red dot in the script."
  },
  {
    "objectID": "files/Session-4-Functions/index.html#do.call",
    "href": "files/Session-4-Functions/index.html#do.call",
    "title": "Writing functions in R",
    "section": "do.call",
    "text": "do.call\ndo.call() takes a function and a list of arguments, and applies the function to the arguments. This can be useful in a variety of situations:\n\n\nTo combine data:\n\na &lt;- list(c(1, 2, 3), c(4, 5, 6))\ndo.call(rbind, a)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\n\n\n\n\nWhen we have a function name as a string:\n\nmy_function &lt;- \"mean\"\ndo.call(my_function, list(c(1, 2, 3)))\n\n[1] 2"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#do.call-1",
    "href": "files/Session-4-Functions/index.html#do.call-1",
    "title": "Writing functions in R",
    "section": "do.call",
    "text": "do.call\nWith dynamic arguments:\n\nFor example, we want to allow the user to specify additional arguments for a custom plot function, including xlim. In case he doesn’t specify it, we want to automatically generate xlim values:\n\n\n\nmy_plot &lt;- function(x, ...) {\n    args &lt;- list(...) # save the additional arguments\n  if(\"xlim\" %in% names(args)) {\n    xlim &lt;- args$xlim # if user provides xlim, use that\n    args$xlim &lt;- NULL # to avoid argument duplication\n  } else {\n    xlim &lt;- range(x) + c(-1, 1) # automatic xlim\n  }\n  do.call(plot, c(list(x = x, xlim = xlim), args))\n}"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#do.call-2",
    "href": "files/Session-4-Functions/index.html#do.call-2",
    "title": "Writing functions in R",
    "section": "do.call",
    "text": "do.call\n\npar(mfrow = c(1,2))\nmy_plot(1:3, pch = 17, \n        main = \"automatic xlim\")\nmy_plot(1:3, pch = 17, xlim = c(1, 5), \n        main = \"user-specified xlim\")"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#measuring-performance",
    "href": "files/Session-4-Functions/index.html#measuring-performance",
    "title": "Writing functions in R",
    "section": "Measuring performance",
    "text": "Measuring performance\nIf you have large data sets and complex functions, you may want to enhance their performance.\n\n\nTo check how long an operation takes, use system.time:\n\nsystem.time(rnorm(10^6))\n\n   user  system elapsed \n   0.02    0.00    0.06"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#measuring-performance-1",
    "href": "files/Session-4-Functions/index.html#measuring-performance-1",
    "title": "Writing functions in R",
    "section": "Measuring performance",
    "text": "Measuring performance\nThe microbenchmark package performs an operation many times, and measures the average time it takes. You can also compare different operations.\n\n\nWhat is faster, rnorm or rlnorm?\n\nmicrobenchmark::microbenchmark(rnorm(10^4),\n                               rlnorm(10^4))\n\nUnit: microseconds\n         expr    min      lq     mean  median     uq    max neval\n  rnorm(10^4)  420.4  471.15  646.696  560.85  805.1 1524.8   100\n rlnorm(10^4) 1124.7 1182.05 1594.604 1454.85 2018.0 2476.0   100"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#profiling",
    "href": "files/Session-4-Functions/index.html#profiling",
    "title": "Writing functions in R",
    "section": "Profiling",
    "text": "Profiling\nThe profvis package lets you identify bottlenecks in your code:\n\n\nshort_pause &lt;- function(x) Sys.sleep(0.1 * x)\nlong_pause &lt;- function(x) Sys.sleep(0.2 * x)\n\ntime_waste &lt;- function(x) {\n  short_pause(x)\n  long_pause(x)\n}\n\n\nprofvis::profvis(time_waste(1))"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#speeding-up-functions",
    "href": "files/Session-4-Functions/index.html#speeding-up-functions",
    "title": "Writing functions in R",
    "section": "Speeding up functions",
    "text": "Speeding up functions\nOnly spend time trying to make your code faster if\n\nit works as intended\nyou have identified the parts that are slowing it down\n\n\n\nHere is a good overview on making R functions run faster: Best coding practices in R"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#memory-allocation",
    "href": "files/Session-4-Functions/index.html#memory-allocation",
    "title": "Writing functions in R",
    "section": "Memory allocation",
    "text": "Memory allocation\nPre-allocating memory is faster than growing objects repeatedly.\n\nAssume, we have recorded the results of 1,000 dice rolls:\n\ndata &lt;- sample.int(6, n = 100, replace = TRUE)\n\n\n\nNow, we want to check which ones show “6”. Compare these two approaches:\n\n\n\nis_six_1 &lt;- function(x) {\n  res &lt;- NULL\n  for (i in seq_along(x)) {\n    res[i] &lt;- x[i] == 6\n  }\n  res\n}\n\n\n\nis_six_2  &lt;- function(x) {\n  res &lt;- rep(NA,length(x))\n  for (i in seq_along(x)) {\n    res[i] &lt;- x[i] == 6\n  }\n  res\n}"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#memory-allocation-1",
    "href": "files/Session-4-Functions/index.html#memory-allocation-1",
    "title": "Writing functions in R",
    "section": "Memory allocation",
    "text": "Memory allocation\nLet’s check which approach is faster:\n\nmicrobenchmark::microbenchmark(is_six_1(data),\n                               is_six_2(data), times = 1000)\n\nUnit: microseconds\n           expr min  lq   mean median uq    max neval\n is_six_1(data) 1.9 2.2 8.1990    2.6  3 4615.3  1000\n is_six_2(data) 1.2 1.6 5.8303    1.7  2 3371.0  1000\n\n\n\n\nis_six_2() is faster, as R doesn’t have to grow the res object in every iteration."
  },
  {
    "objectID": "files/Session-4-Functions/index.html#vectorisation",
    "href": "files/Session-4-Functions/index.html#vectorisation",
    "title": "Writing functions in R",
    "section": "Vectorisation",
    "text": "Vectorisation\nR has many functions that are vectorised. \n\nInstead of running a loop to check each value of our dice rolls, we can check them all at once by taking advantage of the ability of == to take vector input:\n\n\n\nis_six_2  &lt;- function(x) {\n  res &lt;- rep(NA,length(x))\n  for (i in seq_along(x)) {\n    res[i] &lt;- x[i] == 6\n  }\n  res\n}\n\n\n\nis_six_3 &lt;- function(x) {\n  x == 6\n}"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#vectorisation-1",
    "href": "files/Session-4-Functions/index.html#vectorisation-1",
    "title": "Writing functions in R",
    "section": "Vectorisation",
    "text": "Vectorisation\n\nmicrobenchmark::microbenchmark(is_six_2(data), \n                               is_six_3(data), times = 1000)\n\nUnit: nanoseconds\n           expr  min   lq   mean median   uq     max neval\n is_six_2(data) 1100 1300 4098.3   1300 1400 2652800  1000\n is_six_3(data)  200  300 1431.0    300  400 1054000  1000\n\n\n\nThe vectorised version is_six_3() is much faster."
  },
  {
    "objectID": "files/Session-4-Functions/index.html#vectorisation-2",
    "href": "files/Session-4-Functions/index.html#vectorisation-2",
    "title": "Writing functions in R",
    "section": "Vectorisation",
    "text": "Vectorisation\nVectorised matrix functions like rowSums(), colSums() or rowMeans()can lead to impressive speedups:\n\n\ndata &lt;- matrix(rnorm(10^4), nrow = 100)\n\nmicrobenchmark::microbenchmark(\n  apply(data, 2, sum),\n  colSums(data),\n  times = 1000)\n\nUnit: microseconds\n                expr   min     lq     mean median     uq     max neval\n apply(data, 2, sum) 172.8 235.45 378.2109 310.45 401.85 14354.4  1000\n       colSums(data)   8.8   9.70  14.4721  11.50  16.60   120.8  1000"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#rcpp",
    "href": "files/Session-4-Functions/index.html#rcpp",
    "title": "Writing functions in R",
    "section": "Rcpp",
    "text": "Rcpp\nThe Rcpp package allows for integrating C++ code with R, which can make R functions a lot faster. It requires the installation of a C++ compiler (R tools for Windows, Xcode for Mac, possibly “sudo apt-get install r-base-dev” on Linux)\n\n\nRead more at Rcpp: Seamless R and C++ Integration or Avanced R\n\n\n\nI also highly recommend ChatGpt for help with creating C++ functions."
  },
  {
    "objectID": "files/Session-4-Functions/index.html#rcpp-1",
    "href": "files/Session-4-Functions/index.html#rcpp-1",
    "title": "Writing functions in R",
    "section": "Rcpp",
    "text": "Rcpp\nAs an example, let’s compare a random walk implemented in R with one implemented with Rcpp.\n\nFirst, the R version:\n\nrandom_walk_R &lt;- function(steps) {\n  walk &lt;- numeric(steps)\n  for (i in 2:steps) {\n    walk[i] &lt;- walk[i-1] + ifelse(runif(1) &gt; 0.5, 1, -1)\n  }\n  return(walk)\n}"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#rcpp-2",
    "href": "files/Session-4-Functions/index.html#rcpp-2",
    "title": "Writing functions in R",
    "section": "Rcpp",
    "text": "Rcpp\nNext, the Rcpp version:\n\nlibrary(Rcpp)\nsourceCpp(\n'#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericVector random_walk_Rcpp(int steps) {\n  NumericVector walk(steps);\n  for(int i = 1; i &lt; steps; i++) {\n    walk[i] = walk[i-1] + (R::runif(0, 1) &gt; 0.5 ? 1 : -1);\n  }\n  return walk;\n}')\n\n\nWe now have the function random_walk_Rcpp in the global environment."
  },
  {
    "objectID": "files/Session-4-Functions/index.html#rcpp-3",
    "href": "files/Session-4-Functions/index.html#rcpp-3",
    "title": "Writing functions in R",
    "section": "Rcpp",
    "text": "Rcpp\nLet’s make sure both versions work:\n\nplot(random_walk_R(1000), type = \"l\", ylim = c(-50,50))\npoints(random_walk_Rcpp(1000),type = \"l\", col = \"red\")"
  },
  {
    "objectID": "files/Session-4-Functions/index.html#rcpp-4",
    "href": "files/Session-4-Functions/index.html#rcpp-4",
    "title": "Writing functions in R",
    "section": "Rcpp",
    "text": "Rcpp\nNow let us compare the speed:\n\nmicrobenchmark::microbenchmark(\n  random_walk_R(1000),\n  random_walk_Rcpp(1000),\n  times = 100)\n\n\n\n\nLoops are much faster in C++!"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html",
    "href": "files/Session-4-Functions/functions.html",
    "title": "Writing functions in R",
    "section": "",
    "text": "takes input –&gt; does something –&gt; returns output\n\n\nmean(c(1, 2, 3))\n\n[1] 2\n\n\n\n\n\nA function needs a name, arguments in (), and a body in {}\n\nsubtract &lt;- function(arg1, arg2) { \n  arg1 - arg2 \n} \n\n\n\n\n\nsubtract(2, 1)\n\n[1] 1\n\n\n\n\n\n\n\n\n\nReadability\nOrganisation\n\n\n\nModularity\nReusability\n\n\n\n\nImagine calculating the mean without standard functions like mean or sum:\n\n\n\n  data &lt;- c(1,2,3)\n  total &lt;- 0\n  count &lt;- 0\n  for (value in data) {\n    total &lt;- total + value\n    count &lt;- count + 1\n  }\n  total/count\n\n[1] 2\n\n\n\n\n\n\nArguments need to be provided in the correct order, or specified by name: \n\n\nsubtract(2, 1)\n\n[1] 1\n\n\n\n\n\n\nsubtract(1, 2)\n\n[1] -1\n\n\n\n\n\n\nsubtract(arg2 = 1, arg1 = 2)\n\n[1] 1\n\n\n\n\n\n\nMake function use more convenient, can hide complexities.\n\n\nsubtract(2)\n\nError in subtract(2): argument \"arg2\" is missing, with no default\n\n\n\n\n\nThis will work if we set a default for arg2:\n\nsubtract &lt;- function(arg1, arg2 = 1) {\n  arg1 - arg2\n}\n\n\n\n\n\nsubtract(2)\n\n[1] 1\n\n\n\n\n\n\n\nAdditional, optional arguments can be allowed by using ‘…’ as the last argument:\n\n\nmy_plot &lt;- function(arg1, arg2, ...) {\n  plot(arg1, arg2, ...)\n}\n\n\n\n\n\nmy_plot(2, 1, col = \"red\", pch = 17, cex = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA function generally should return something, but this does not:\n\n\nsubtract &lt;- function(arg1, arg2) {\n  result &lt;- arg1 - arg2\n}\n\n\n\n\nsubtract(2,1)\n\n\n\n\nReturn explicitly with return, or place return value at the end of the function:\n\nsubtract &lt;- function(arg1, arg2) {\n  result &lt;- arg1 - arg2\n  return(result)\n}\n\n\n\n\nsubtract(2,1)\n\n[1] 1\n\n\n\n\n\n\n\n\n\njust_return &lt;- function(arg1, arg2) {\nreturn(arg1)\nreturn(arg2)\n}\n\n\n\n\njust_return(2, 1)\n\n[1] 2\n\n\nThis did not work as intended. R functions only return one object. Instead use lists or other data structures:\n\n\n\njust_return &lt;- function(arg1, arg2) {\nreturn(c(arg1, arg2))\n}\n\n\n\n\njust_return(2, 1)\n\n[1] 2 1\n\n\n\n\n\n\nWrite a function that adds two values and creates a scatter plot with first value on the x-axis and the result on the y axis.\n\n\n\n\nClick to expand/collapse\n\nFirst, we add the two values and save it in an object within the function. Then, we use the plot function to create a scatter plot with x being the first value, and y being the object we created with the addtion.\n\n\n\n\n\n\nClick to expand/collapse\n\n\nadd_and_plot &lt;- function(a, b) {\n  result &lt;- a + b\n  plot(a, result)\n}\n\n\n\n\n\n\nExpand the function you just created to let it return the result after plotting\n\n\n\n\nClick to expand/collapse\n\nWe can place the object we want to return at the end of our function, or use the return function.\n\n\n\n\n\n\nClick to expand/collapse\n\n\nadd_and_plot &lt;- function(a, b) {\n  result &lt;- a + b\n  plot(a, result)\n  result\n}\n\n\n\n\n\n\nExpand the function further by allowing customisation of the plot by changing graphical parameters.\n\n\n\n\nClick to expand/collapse\n\nWe can use ellipsis (...) as a function argument in the outer and the inner function to allow for additional arguments being passed.\n\n\n\n\n\n\nClick to expand/collapse\n\n\nadd_and_plot &lt;- function(a, b, ...) {\n  result &lt;- a + b\n  plot(a, result, ...)\n  result\n}"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#what-is-a-function",
    "href": "files/Session-4-Functions/functions.html#what-is-a-function",
    "title": "Writing functions in R",
    "section": "",
    "text": "takes input –&gt; does something –&gt; returns output\n\n\nmean(c(1, 2, 3))\n\n[1] 2\n\n\n\n\n\nA function needs a name, arguments in (), and a body in {}\n\nsubtract &lt;- function(arg1, arg2) { \n  arg1 - arg2 \n} \n\n\n\n\n\nsubtract(2, 1)\n\n[1] 1"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#why-do-we-need-functions",
    "href": "files/Session-4-Functions/functions.html#why-do-we-need-functions",
    "title": "Writing functions in R",
    "section": "",
    "text": "Readability\nOrganisation\n\n\n\nModularity\nReusability\n\n\n\n\nImagine calculating the mean without standard functions like mean or sum:\n\n\n\n  data &lt;- c(1,2,3)\n  total &lt;- 0\n  count &lt;- 0\n  for (value in data) {\n    total &lt;- total + value\n    count &lt;- count + 1\n  }\n  total/count\n\n[1] 2"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#arguments",
    "href": "files/Session-4-Functions/functions.html#arguments",
    "title": "Writing functions in R",
    "section": "",
    "text": "Arguments need to be provided in the correct order, or specified by name: \n\n\nsubtract(2, 1)\n\n[1] 1\n\n\n\n\n\n\nsubtract(1, 2)\n\n[1] -1\n\n\n\n\n\n\nsubtract(arg2 = 1, arg1 = 2)\n\n[1] 1"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#default-values",
    "href": "files/Session-4-Functions/functions.html#default-values",
    "title": "Writing functions in R",
    "section": "",
    "text": "Make function use more convenient, can hide complexities.\n\n\nsubtract(2)\n\nError in subtract(2): argument \"arg2\" is missing, with no default\n\n\n\n\n\nThis will work if we set a default for arg2:\n\nsubtract &lt;- function(arg1, arg2 = 1) {\n  arg1 - arg2\n}\n\n\n\n\n\nsubtract(2)\n\n[1] 1"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#ellipsis",
    "href": "files/Session-4-Functions/functions.html#ellipsis",
    "title": "Writing functions in R",
    "section": "",
    "text": "Additional, optional arguments can be allowed by using ‘…’ as the last argument:\n\n\nmy_plot &lt;- function(arg1, arg2, ...) {\n  plot(arg1, arg2, ...)\n}\n\n\n\n\n\nmy_plot(2, 1, col = \"red\", pch = 17, cex = 2)"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#return",
    "href": "files/Session-4-Functions/functions.html#return",
    "title": "Writing functions in R",
    "section": "",
    "text": "A function generally should return something, but this does not:\n\n\nsubtract &lt;- function(arg1, arg2) {\n  result &lt;- arg1 - arg2\n}\n\n\n\n\nsubtract(2,1)\n\n\n\n\nReturn explicitly with return, or place return value at the end of the function:\n\nsubtract &lt;- function(arg1, arg2) {\n  result &lt;- arg1 - arg2\n  return(result)\n}\n\n\n\n\nsubtract(2,1)\n\n[1] 1"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#return-multiple-objects",
    "href": "files/Session-4-Functions/functions.html#return-multiple-objects",
    "title": "Writing functions in R",
    "section": "",
    "text": "just_return &lt;- function(arg1, arg2) {\nreturn(arg1)\nreturn(arg2)\n}\n\n\n\n\njust_return(2, 1)\n\n[1] 2\n\n\nThis did not work as intended. R functions only return one object. Instead use lists or other data structures:\n\n\n\njust_return &lt;- function(arg1, arg2) {\nreturn(c(arg1, arg2))\n}\n\n\n\n\njust_return(2, 1)\n\n[1] 2 1"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#exercise-1a---building-a-function",
    "href": "files/Session-4-Functions/functions.html#exercise-1a---building-a-function",
    "title": "Writing functions in R",
    "section": "",
    "text": "Write a function that adds two values and creates a scatter plot with first value on the x-axis and the result on the y axis.\n\n\n\n\nClick to expand/collapse\n\nFirst, we add the two values and save it in an object within the function. Then, we use the plot function to create a scatter plot with x being the first value, and y being the object we created with the addtion.\n\n\n\n\n\n\nClick to expand/collapse\n\n\nadd_and_plot &lt;- function(a, b) {\n  result &lt;- a + b\n  plot(a, result)\n}"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#exercise-1b---expanding-a-function",
    "href": "files/Session-4-Functions/functions.html#exercise-1b---expanding-a-function",
    "title": "Writing functions in R",
    "section": "",
    "text": "Expand the function you just created to let it return the result after plotting\n\n\n\n\nClick to expand/collapse\n\nWe can place the object we want to return at the end of our function, or use the return function.\n\n\n\n\n\n\nClick to expand/collapse\n\n\nadd_and_plot &lt;- function(a, b) {\n  result &lt;- a + b\n  plot(a, result)\n  result\n}"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#exercise-1c---passing-additional-arguments",
    "href": "files/Session-4-Functions/functions.html#exercise-1c---passing-additional-arguments",
    "title": "Writing functions in R",
    "section": "",
    "text": "Expand the function further by allowing customisation of the plot by changing graphical parameters.\n\n\n\n\nClick to expand/collapse\n\nWe can use ellipsis (...) as a function argument in the outer and the inner function to allow for additional arguments being passed.\n\n\n\n\n\n\nClick to expand/collapse\n\n\nadd_and_plot &lt;- function(a, b, ...) {\n  result &lt;- a + b\n  plot(a, result, ...)\n  result\n}"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#binary-operators-1",
    "href": "files/Session-4-Functions/functions.html#binary-operators-1",
    "title": "Writing functions in R",
    "section": "Binary operators",
    "text": "Binary operators\n\n\n\nStandard function syntax:\n\nsum(c(1,2))\n\n[1] 3\n\n\n\n\n\nOperator syntax:\n\n1 + 2\n\n[1] 3\n\n\n\n\n\n\n\n\nMost binary operators come in %:\n\n\n\n\n3 %in% c(1,2,3)\n\n[1] TRUE\n\n\n\n\n\n\n\nCustom binary operators – let’s define an operator for “not in”:\n\n`%!in%` &lt;- function(x, y) !(x %in% y)\n\n\n\n\n3 %!in% c(1,2,3)\n\n[1] FALSE"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#control-structures-if",
    "href": "files/Session-4-Functions/functions.html#control-structures-if",
    "title": "Writing functions in R",
    "section": "Control structures – if",
    "text": "Control structures – if\nif a condition is true, do something.\n\n\nif (1 + 1 == 2) print(\"True\")\n\n[1] \"True\"\n\n\n\n\n\n\nadd_or_subtract &lt;- function(arg1, arg2, operation) {\n if (operation == \"add\") {\n   result &lt;- arg1 + arg2\n }\n if (operation == \"subtract\") {\n   result &lt;- arg1 + arg2\n }\n result\n}\n\n\n\n\nadd_or_subtract(2,1,\"add\")\n\n[1] 3"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#control-structures-else",
    "href": "files/Session-4-Functions/functions.html#control-structures-else",
    "title": "Writing functions in R",
    "section": "Control structures – else",
    "text": "Control structures – else\nelse instructs what to do when the if condition is not met.\n\n\nif (1 + 1 == 3) print(\"True\") else print(\"False\")\n\n[1] \"False\"\n\n\n\n\n\n\nadd_or_subtract &lt;- function(arg1, arg2, operation) {\n if (operation == \"add\") {\n   result &lt;- arg1 + arg2\n } else {\n   result &lt;- arg1 - arg2\n }\n return(result)\n}\n\n\n\n\nadd_or_subtract(2,1,\"subtract\")\n\n[1] 1"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#control-structures-switch",
    "href": "files/Session-4-Functions/functions.html#control-structures-switch",
    "title": "Writing functions in R",
    "section": "Control structures – switch",
    "text": "Control structures – switch\nInstead of many if and else statements, try switch\n\n\nfossil_description &lt;- function(fossil) {\n switch(fossil,\n  ammonite = \"coiled shell\",\n  Tyrannosaurus = \"serrated teeth\",\n  Lepidodendron = \"scaly bark\", \n  \"not a fossil\"\n )\n}\n\n\n\n\nfossil_description(\"Tyrannosaurus\")\n\n[1] \"serrated teeth\"\n\n\n\n\n\nfossil_description(\"laptop\")\n\n[1] \"not a fossil\""
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#control-structures-for-loops",
    "href": "files/Session-4-Functions/functions.html#control-structures-for-loops",
    "title": "Writing functions in R",
    "section": "Control structures – for loops",
    "text": "Control structures – for loops\nLoops are used for repeating similar actions multiple times. for loops iterate over a set of values. The iterator (i) changes with every iteration of the loop:\n\n\nfor (i in c(1,2,3)) print(i)\n\n[1] 1\n[1] 2\n[1] 3\n\n\n\n\nTo generate sequences of integers, we can use seq_len. Let’s make a function:\n\nprint_repetitions &lt;- function(n) {\n for (i in seq_len(n)) { \n   print(i)\n }\n}\n\n\n\n\nprint_repetitions(2)\n\n[1] 1\n[1] 2"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#control-structures-while-loops",
    "href": "files/Session-4-Functions/functions.html#control-structures-while-loops",
    "title": "Writing functions in R",
    "section": "Control structures – while loops",
    "text": "Control structures – while loops\nwhile loops repeat a task until a condition is no longer met.\n\n\nadd_until_4 &lt;- function(x) {\n  while(x &lt; 4) {\n    x &lt;- x + 1\n    print(x)\n  }\n}\n\n\n\n\nadd_until_4(1)\n\n[1] 2\n[1] 3\n[1] 4"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#exercise-2a---building-a-loop",
    "href": "files/Session-4-Functions/functions.html#exercise-2a---building-a-loop",
    "title": "Writing functions in R",
    "section": "Exercise 2a - Building a loop",
    "text": "Exercise 2a - Building a loop\nCreate a for loop that calculates the mean of all numerical columns of the Talat_isotopes dataset. If the dataset is not already loaded, we can read it with:\n\n# read the \"Talat_n_Yissi_isotopes.csv\" from session 3:\nTalat_isotopes &lt;- read.csv(\"data/Talat_n_Yissi_isotopes.csv\", \n                           header = TRUE)\n\n\nHint 1\n\n\nClick to expand/collapse\n\nTo check if a column is numeric, we can use is.numeric on the column. Using if and possibly else allows us to do different operations depending on the outcome of is.numeric.\nSelecting a column can be done with square brackets, e.g. Talat_isotopes[ ,1] selects the first column.\nTo get the number of columns of Talat_isotopes, we can use the ncol function.\n\n\n\nHint 2\n\n\nClick to expand/collapse\n\nStart a loop for example with for (i in seq_len(ncol(Talat_isotopes))) { } to run it for one iteration per number of columns. Everything inside the curly brackets is done exactly the same in each iteration, except i changes. To print the output at every iteration of the function, we can use the print function.\n\n\n\nSolution\n\n\nClick to expand/collapse\n\n\n# save number of columns\nnCol &lt;- ncol(Talat_isotopes)\n# run loop for nCol iterations\nfor (i in seq_len(nCol)) {\n  if(is.numeric(Talat_isotopes[,i])) {\n    print(mean(Talat_isotopes[,i]))\n  }\n}\n\n[1] -0.335762\n[1] -10.78194\n[1] 411.5718\n[1] 519.5261\n[1] 205.5268"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#exercise-2b---turn-the-loop-into-a-function",
    "href": "files/Session-4-Functions/functions.html#exercise-2b---turn-the-loop-into-a-function",
    "title": "Writing functions in R",
    "section": "Exercise 2b - Turn the loop into a function",
    "text": "Exercise 2b - Turn the loop into a function\nFrom the loop created in exercise 1, create a function that takes the Talat_isotopes dataframe (or any other dataframe) as input and returns the means of numerical columns as output.\n\nHint\n\n\nClick to expand/collapse\n\nWe can return the output by saving the result of every iteration of the loop in an object, and then return that object. We can omit NA output by indexing with !is.na.\n\n\n\nSolution\n\n\nClick to expand/collapse\n\n\nnumericColumnMean &lt;- function(df) {\n  # save number of columns\n  nCol &lt;- ncol(df)\n  # create a vector for the output\n  output &lt;- rep(NA,nCol)\n  # run loop for nCol iterations\n  for (i in seq_len(nCol)) {\n    if(is.numeric(df[,i])) {\n      output[i] &lt;- mean(df[,i])\n    } else {  # NA for non-numeric columns:\n      output[i] &lt;- NA \n      }\n  }\n  # return output that is not NA\n  output[!is.na(output)]\n}\n# apply function\nnumericColumnMean(Talat_isotopes)\n\n[1]  -0.335762 -10.781942 411.571816 519.526138 205.526785"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#apply",
    "href": "files/Session-4-Functions/functions.html#apply",
    "title": "Writing functions in R",
    "section": "apply",
    "text": "apply\n\napply and related functions apply a function to elements of arrays, lists, …\nmore concise than loops and don’t change global environment\n\n\nFor example, to get the classes of the first three columns of the Talat_isotopes data:\n\nTalat_classes &lt;- rep(NA,3)\nfor (i in 1:3) {\n  Talat_classes[i] &lt;- class(Talat_isotopes[,i])\n}\nTalat_classes\n\n[1] \"character\" \"numeric\"   \"numeric\"  \n\n\n\n\nOr with apply:\n\napply(Talat_isotopes[,1:3], MARGIN = 2, FUN = class)\n\n     sample        d13C        d18O \n\"character\" \"character\" \"character\""
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#apply-1",
    "href": "files/Session-4-Functions/functions.html#apply-1",
    "title": "Writing functions in R",
    "section": "apply",
    "text": "apply\nLet’s have a look what happened there. apply(X, MARGIN, FUN) takes an array X (our Talat_isotopes dataframe), and applies a function (FUN) to elements of that array, specified by MARGIN.\n\n\n\n\nMARGIN = 2 indicates columns, MARGIN = 1 would be rows. So here we applied the class function to every column of Talat_isotopes.\n\n\n\napply simplifies the output, so here it returned a vector with one element for each column."
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#lapply",
    "href": "files/Session-4-Functions/functions.html#lapply",
    "title": "Writing functions in R",
    "section": "lapply",
    "text": "lapply\nlapply is similar to apply but for list or vector input. It returns a list for each element of the data.\n\n\ndata &lt;- list(c(1, 2, 3), c(4, 5))\nlapply(data, mean)\n\n[[1]]\n[1] 2\n\n[[2]]\n[1] 4.5\n\n\n\n\n\n\n\nsapply does the same, but also tries to simplify the output; here we get a vector:\n\ndata &lt;- list(c(1, 2, 3), c(4, 5))\nsapply(data, mean)\n\n[1] 2.0 4.5"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#vapply",
    "href": "files/Session-4-Functions/functions.html#vapply",
    "title": "Writing functions in R",
    "section": "vapply",
    "text": "vapply\nvapply is a safer version of sapply, it requires the user to specify the anticipated class and length of the elements of the output:\n\n\n\n\n\ndata &lt;- list(c(1, 2, 3), c(4, 5))\nvapply(data, FUN = mean, FUN.VALUE = numeric(1))\n\n[1] 2.0 4.5\n\n\n\n\n\nHere, we specified in FUN.VALUE that each element of the output should be a numeric of length 1."
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#exercise-3a---use-apply-to-calculate-column-means",
    "href": "files/Session-4-Functions/functions.html#exercise-3a---use-apply-to-calculate-column-means",
    "title": "Writing functions in R",
    "section": "Exercise 3a - Use apply to calculate column means",
    "text": "Exercise 3a - Use apply to calculate column means\nIn exercise 2, we built a function that calculated the mean of all numerical columns of the Talat_isotopes dataset and returned it.\nCan we achieve the same using apply?\nThis task is trickier than it looks like as apply coerces all columns to type character as soon as there is even one character column. We can add as.numeric to try and force columns into numeric. Better yet, we just select the columns containing values that can be coerced to be numeric:\n\nnumeric_columns &lt;- c(\"d18O\", \"d13C\", \"m\", \"age\", \"m.my\")\nTalat_numeric &lt;- Talat_isotopes[ ,numeric_columns]\n\n\nHint 1\n\n\nClick to expand/collapse\n\nThe second argument of apply, MAR, needs to be set to 2 for columnwise operations.\nIn the third argument, we can define a function, for example function(col) { } will modify each column according to the instructions in curly brackets, refering to the column as col.\n\n\n\nSolution\n\n\nClick to expand/collapse\n\n\napply(Talat_numeric, 2, function (col) {\n  mean(col)\n  }\n)\n\n      d18O       d13C          m        age       m.my \n-10.781942  -0.335762 411.571816 519.526138 205.526785 \n\n\nOr simply:\n\napply(Talat_numeric, 2, mean)\n\n      d18O       d13C          m        age       m.my \n-10.781942  -0.335762 411.571816 519.526138 205.526785"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#exercise-3b---reading-a-messy-dataset",
    "href": "files/Session-4-Functions/functions.html#exercise-3b---reading-a-messy-dataset",
    "title": "Writing functions in R",
    "section": "Exercise 3b - Reading a messy dataset",
    "text": "Exercise 3b - Reading a messy dataset\nThe Talat_isotopes and Talat_elements datasets are contained in a mulit-sheet Excel file from the supplementary materials Maloof et al. (2010). It is in the data folder and named Maloof_et_al_2010_SM.xls.\nReading such files with R can be a challenge and it is often easier to copy-paste the relevant data into clean spreadsheets and save them as .csv files.\nHowever, here we try to automate the reading of sheets from this particular file, starting from the sheet Morocco-Talat n’ Yissi`.\nWe start by installing and loading the readxl package.\n\n# Install and load the readxl package if you haven't already\nif (!require(readxl)) install.packages(\"readxl\")\n\nLoading required package: readxl\n\nlibrary(readxl)\n\nWe notice that the Morocco-Talat n' Yissi sheet has two header rows, and the formatting is messy.\nWe read in the header rows of the sheet 4. Morocco-Talat n' Yissi:\n\n# specify the file path\nfile_path &lt;- \"data/Maloof_et_al_2010_SM.xls\"\n# specify the sheet name\nsheet_name &lt;- \"4. Morocco-Talat n' Yissi\"\n# read the top two rows\n# trim_ws stops omitting empty cells\n# col_names = FALSE stops cells being used as column names\nheader_rows &lt;- read_excel(file_path, sheet = sheet_name, n_max = 2,\n                          trim_ws = FALSE, col_names = FALSE)\n\nNew names:\n• `` -&gt; `...1`\n• `` -&gt; `...2`\n• `` -&gt; `...3`\n• `` -&gt; `...4`\n• `` -&gt; `...5`\n• `` -&gt; `...6`\n• `` -&gt; `...7`\n• `` -&gt; `...8`\n• `` -&gt; `...9`\n• `` -&gt; `...10`\n• `` -&gt; `...11`\n• `` -&gt; `...12`\n• `` -&gt; `...13`\n• `` -&gt; `...14`\n• `` -&gt; `...15`\n• `` -&gt; `...16`\n• `` -&gt; `...17`\n• `` -&gt; `...18`\n• `` -&gt; `...19`\n• `` -&gt; `...20`\n• `` -&gt; `...21`\n• `` -&gt; `...22`\n• `` -&gt; `...23`\n• `` -&gt; `...24`\n• `` -&gt; `...25`\n• `` -&gt; `...26`\n• `` -&gt; `...27`\n• `` -&gt; `...28`\n• `` -&gt; `...29`\n• `` -&gt; `...30`\n• `` -&gt; `...31`\n• `` -&gt; `...32`\n• `` -&gt; `...33`\n• `` -&gt; `...34`\n• `` -&gt; `...35`\n• `` -&gt; `...36`\n• `` -&gt; `...37`\n• `` -&gt; `...38`\n• `` -&gt; `...39`\n• `` -&gt; `...40`\n• `` -&gt; `...41`\n• `` -&gt; `...42`\n• `` -&gt; `...43`\n• `` -&gt; `...44`\n• `` -&gt; `...45`\n• `` -&gt; `...46`\n• `` -&gt; `...47`\n• `` -&gt; `...48`\n• `` -&gt; `...49`\n• `` -&gt; `...50`\n• `` -&gt; `...51`\n• `` -&gt; `...52`\n• `` -&gt; `...53`\n• `` -&gt; `...54`\n• `` -&gt; `...55`\n• `` -&gt; `...56`\n• `` -&gt; `...57`\n• `` -&gt; `...58`\n• `` -&gt; `...59`\n• `` -&gt; `...60`\n• `` -&gt; `...61`\n• `` -&gt; `...62`\n• `` -&gt; `...63`\n• `` -&gt; `...64`\n• `` -&gt; `...65`\n• `` -&gt; `...66`\n• `` -&gt; `...67`\n• `` -&gt; `...68`\n• `` -&gt; `...69`\n• `` -&gt; `...70`\n• `` -&gt; `...71`\n• `` -&gt; `...72`\n• `` -&gt; `...73`\n• `` -&gt; `...74`\n• `` -&gt; `...75`\n• `` -&gt; `...76`\n• `` -&gt; `...77`\n\n\nNext, we merge the header rows as we want only a single column name per column:\n\ncolumn_names &lt;- apply(header_rows, 2, function(x) paste(na.omit(x), collapse = \"_\"))\n\nFinally, we use these column names for reading the entire data set, skipping the first two problematic rows:\n\ntalat &lt;- read_excel(file_path, sheet = sheet_name, skip = 2, col_names = column_names)\n\nNew names:\n• `` -&gt; `...17`\n• `` -&gt; `...18`\n• `` -&gt; `...19`\n\n\nThe result looks reasonable:\n\nhead(talat[ ,c(1:4)])\n\n# A tibble: 6 × 4\n  `0_sample`  d13C   d18O d13Corg\n  &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt;  \n1 M250-2.1   -2.07  -7.95 NA     \n2 M250-2.6   -1.78 -10.7  NA     \n3 M250-3.6   -2.04 -10.9  NA     \n4 M250-4.4   -2.34  -9.53 NA     \n5 M250-6.1   -2.04  -8.92 NA     \n6 M250-7.5   -1.59  -6.84 NA     \n\n\nExercise: Can you build a function from the above and apply it to other sheets of the Maloof_et_al_2010_SM.xls file? We can also build a second function that uses this function to read multiple sheets at once.\n\nHint\n\n\nClick to expand/collapse\n\nWe can almost copy-paste the lines we used to read the sheet earlier and collate them in a function.\nWe need two arguments: the file_path, and the sheet_index.\nlapply is useful if we want to use that function on multiple sheets at once.\n\n\n\nSolution\n\n\nClick to expand/collapse\n\nHere is a function that reads a single sheet:\n\nread_sheets_Maloof &lt;- function(file_path, sheet_index) {\n  # read the top two rows\n  header_rows &lt;- read_excel(file_path, sheet = sheet_index, n_max = 2,\n                            trim_ws = FALSE, col_names = FALSE)\n  # merge to column names\n  column_names &lt;- apply(header_rows, 2, function(x) {\n    paste(na.omit(x), collapse = \"_\")\n  })\n  # read the rest of the file\n  output &lt;- read_excel(file_path, sheet = sheet_index, \n                       skip = 2, col_names = column_names)\n  output\n}\n\nUsing lapply, we can build a simple function that uses the previous function to read multiple sheets at once and saves them as a list of dataframes. Here, we use the indices of the sheets, rather than the names, so we don’t have to type out the complicated sheet names.\n\nmulti_sheets_Maloof &lt;- function(file_path, sheet_index, \n                                read_function) {\n  # do this for every sheet index (integers)\n  lapply(sheet_index, function(s) {\n    read_function(file_path = file_path, sheet_index = s)\n  })\n}\n\nFrom here, you could try to combine the dataframes e.g. using merge."
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#environment",
    "href": "files/Session-4-Functions/functions.html#environment",
    "title": "Writing functions in R",
    "section": "Environment",
    "text": "Environment\nEnvironment can be conceptualised as a place where objects with a name and value exist.\n\nFor example, when we run\n\nx &lt;- 1\n\nx now exists in the global environment, and has the value 1.\n\n\n\nEach function, for loop, …, creates its own environment."
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#environment-1",
    "href": "files/Session-4-Functions/functions.html#environment-1",
    "title": "Writing functions in R",
    "section": "Environment",
    "text": "Environment\nIf we run the following function to assign to b the value of a\n\na_to_b &lt;- function(a) b &lt;- a\na_to_b(a = 1)\n\n\nand then look for b in the global environment\n\n\n\nb\n\nError in eval(expr, envir, enclos): object 'b' not found\n\n\nwe get an error because b only existed within the function environment.\n\n\n\nMore on environments: adv-r.hadley.nz/environments.html"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#scoping",
    "href": "files/Session-4-Functions/functions.html#scoping",
    "title": "Writing functions in R",
    "section": "Scoping",
    "text": "Scoping\nR uses scoping rules to look for variables (or functions). If a variable is not found in a function environment, R looks in the parent environment (i.e. the environment in which the function was created).\n\n\nx &lt;- 1\ndouble_x &lt;- function(y) 2 * x + y\ndouble_x(0)\n\n[1] 2\n\n\n\n\nx is a free variable in the double_x function – it is not supplied to or defined in the function. Instead, it’s looked up in the environment where double_x was created, the global environment.\n\n\n\nThis can get tricky, see here for more details: bookdown.org/rdpeng/rprogdatascience/scoping-rules-of-r.html"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#exercise-4---use-vapply-to-return-the-three-highest-d13c-values-for-every-stage-in-talat_isotopes",
    "href": "files/Session-4-Functions/functions.html#exercise-4---use-vapply-to-return-the-three-highest-d13c-values-for-every-stage-in-talat_isotopes",
    "title": "Writing functions in R",
    "section": "Exercise 4 - Use vapply to return the three highest d13C values for every stage in Talat_isotopes",
    "text": "Exercise 4 - Use vapply to return the three highest d13C values for every stage in Talat_isotopes\nAs a starting point, extract the unique stage names from the Talat_isotopes dataframe using the unique function:\n\nunique_stages &lt;- unique(Talat_isotopes$stage)\n\n\nHint\n\n\nClick to expand/collapse\n\nWe can use this as our first argument to vapply, and use subset to select only the values of d13C that are from a specific stage.\nThe sort function can be useful to sort the d13C values in decreasing order, for example:\n\n# function to return three largest elements of a vector\nthree_largest &lt;- function(x) {\n  # sort vector in decreasing order\n  x &lt;- sort(x, decreasing = TRUE)\n  # return the first three values\n  x[1:3]\n}\n\nInstead of passing Talat_isotopes as an argument, we can let it look up in the global environment, where it was defined.\nThe third argument of vapply needs to specify the class and length of the output. In our case, it will be three numeric values: numeric(3)\n\n\n\nSolution\n\n\nClick to expand/collapse\n\nThe first solution takes advantage of R functions being able to find variables that were defined outside the function environment:\n\n# build a custom function for vapply\nthree_largest_stages &lt;- function(s) {\n  # subset to only include rows from the current stage\n  # note: we haven't passed Talat_isotopes as a function argument\n  Talat_isotopes &lt;- subset(Talat_isotopes, stage == s)\n  # extract three largest values\n  three_largest(Talat_isotopes$d13C)\n}\n# put everything together\nvapply(unique_stages, FUN = three_largest_stages, \n       FUN.VALUE = numeric(3))\n\n        T    A    B\n[1,] 0.74 3.46 1.79\n[2,] 0.37 3.44 1.78\n[3,] 0.34 3.43 1.76\n\n\nvapply has returned the output as a matrix.\nThe function above works because Talat_isotopes is accessed from the global environment, but only modified within the function environment.\nCaution: This can lead to confusion and it is often better to avoid this.\nA cleaner solution would be to pass Talat_isotopes as a second argument to the three_largest_stages function."
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#error-handling",
    "href": "files/Session-4-Functions/functions.html#error-handling",
    "title": "Writing functions in R",
    "section": "Error handling",
    "text": "Error handling\nVery helpful in complex functions\n\n\nsubtract(2, 1)\n\n[1] 1\n\n\n\n\n\nsubtract(\"2\", 1)\n\nError in arg1 - arg2: non-numeric argument to binary operator\n\n\n\n\n\n\n\nCheck that input is correct and display custom error messages:\n\nsubtract &lt;- function(arg1, arg2) {\n  if (is.numeric(arg1) == FALSE) {\n    stop(\"`arg1` must be numeric\") \n    }\n  arg1 - arg2\n}\n\n\n\n\nsubtract(\"2\", 1)\n\nError in subtract(\"2\", 1): `arg1` must be numeric"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#trycatch",
    "href": "files/Session-4-Functions/functions.html#trycatch",
    "title": "Writing functions in R",
    "section": "tryCatch",
    "text": "tryCatch\nUse if you anticipate an error but want function to continue.\n\n\n\n\nLet’s try to generate data from a multivariate normal distribution:\n\nmvnfast::rmvn(1, mu = c(0,0), sigma = matrix(rep(1,4), 2))\n\nError in eval(expr, envir, enclos): chol(): decomposition failed\n\n\n\n\n\n\n\nmvnfast::rmvn is fast but fails for some problematic sigma values. In case it fails, we use MASS::mvrnorm instead:\n\nmy_rmvn &lt;- function(n, mu, sigma) {\n  tryCatch(mvnfast::rmvn(n, mu, sigma),\n           error = function(e) MASS::mvrnorm(n, mu, sigma))\n}\n\n\n\n\nmy_rmvn(n = 1, mu = c(0,0), sigma = matrix(rep(1,4), 2))\n\n[1] 0.7173393 0.7173393"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#traceback",
    "href": "files/Session-4-Functions/functions.html#traceback",
    "title": "Writing functions in R",
    "section": "Traceback",
    "text": "Traceback\nIf something went wrong, find out where using traceback():\n\n\nmy_rmvn(n = 1, mu = 0, sigma = matrix(rep(1,4), 2))\n\nError in MASS::mvrnorm(n, mu, sigma): incompatible arguments\n\n\n\n\n\n\n\n\ntraceback()"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#break-points",
    "href": "files/Session-4-Functions/functions.html#break-points",
    "title": "Writing functions in R",
    "section": "Break points",
    "text": "Break points\nBreak points allow you to look inside your function’s environment. This works best when the function is in a separate script. Click next to a line of code in your function to activate a break point (a red dot appears):\n\n\n\n\nNow run the function…\n\nmy_rmvn(n = 1, mu = c(0,0), sigma = matrix(rep(1,4), 2))\n\n\n\nYou may need to save the script and source it (press source in the Rstudio toolbar)"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#break-points-1",
    "href": "files/Session-4-Functions/functions.html#break-points-1",
    "title": "Writing functions in R",
    "section": "Break points",
    "text": "Break points"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#break-points-2",
    "href": "files/Session-4-Functions/functions.html#break-points-2",
    "title": "Writing functions in R",
    "section": "Break points",
    "text": "Break points\nWe can now browse the function environment in the console like we normally can browse the global environment. For example we can look at sigma:\n\nPress Stop to end the browsing. Don’t forget to deactivate the break point by clicking on the red dot in the script."
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#do.call",
    "href": "files/Session-4-Functions/functions.html#do.call",
    "title": "Writing functions in R",
    "section": "do.call",
    "text": "do.call\ndo.call() takes a function and a list of arguments, and applies the function to the arguments. This can be useful in a variety of situations:\n\n\nTo combine data:\n\na &lt;- list(c(1, 2, 3), c(4, 5, 6))\ndo.call(rbind, a)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\n\n\n\n\nWhen we have a function name as a string:\n\nmy_function &lt;- \"mean\"\ndo.call(my_function, list(c(1, 2, 3)))\n\n[1] 2"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#do.call-1",
    "href": "files/Session-4-Functions/functions.html#do.call-1",
    "title": "Writing functions in R",
    "section": "do.call",
    "text": "do.call\nWith dynamic arguments:\n\nFor example, we want to allow the user to specify additional arguments for a custom plot function, including xlim. In case he doesn’t specify it, we want to automatically generate xlim values:\n\n\n\nmy_plot &lt;- function(x, ...) {\n    args &lt;- list(...) # save the additional arguments\n  if(\"xlim\" %in% names(args)) {\n    xlim &lt;- args$xlim # if user provides xlim, use that\n    args$xlim &lt;- NULL # to avoid argument duplication\n  } else {\n    xlim &lt;- range(x) + c(-1, 1) # automatic xlim\n  }\n  do.call(plot, c(list(x = x, xlim = xlim), args))\n}"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#do.call-2",
    "href": "files/Session-4-Functions/functions.html#do.call-2",
    "title": "Writing functions in R",
    "section": "do.call",
    "text": "do.call\n\npar(mfrow = c(1,2))\nmy_plot(1:3, pch = 17, \n        main = \"automatic xlim\")\nmy_plot(1:3, pch = 17, xlim = c(1, 5), \n        main = \"user-specified xlim\")"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#measuring-performance",
    "href": "files/Session-4-Functions/functions.html#measuring-performance",
    "title": "Writing functions in R",
    "section": "Measuring performance",
    "text": "Measuring performance\nIf you have large data sets and complex functions, you may want to enhance their performance.\n\n\nTo check how long an operation takes, use system.time:\n\nsystem.time(rnorm(10^6))\n\n   user  system elapsed \n   0.02    0.00    0.06"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#measuring-performance-1",
    "href": "files/Session-4-Functions/functions.html#measuring-performance-1",
    "title": "Writing functions in R",
    "section": "Measuring performance",
    "text": "Measuring performance\nThe microbenchmark package performs an operation many times, and measures the average time it takes. You can also compare different operations.\n\n\nWhat is faster, rnorm or rlnorm?\n\nmicrobenchmark::microbenchmark(rnorm(10^4),\n                               rlnorm(10^4))\n\nUnit: microseconds\n         expr    min     lq     mean  median      uq    max neval\n  rnorm(10^4)  442.2  472.5  673.620  620.40  818.40 1444.6   100\n rlnorm(10^4) 1144.2 1165.4 1646.834 1375.15 2010.25 3677.7   100"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#profiling",
    "href": "files/Session-4-Functions/functions.html#profiling",
    "title": "Writing functions in R",
    "section": "Profiling",
    "text": "Profiling\nThe profvis package lets you identify bottlenecks in your code:\n\n\nshort_pause &lt;- function(x) Sys.sleep(0.1 * x)\nlong_pause &lt;- function(x) Sys.sleep(0.2 * x)\n\ntime_waste &lt;- function(x) {\n  short_pause(x)\n  long_pause(x)\n}\n\n\nprofvis::profvis(time_waste(1))"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#speeding-up-functions",
    "href": "files/Session-4-Functions/functions.html#speeding-up-functions",
    "title": "Writing functions in R",
    "section": "Speeding up functions",
    "text": "Speeding up functions\nOnly spend time trying to make your code faster if\n\nit works as intended\nyou have identified the parts that are slowing it down\n\n\n\nHere is a good overview on making R functions run faster: Best coding practices in R"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#memory-allocation",
    "href": "files/Session-4-Functions/functions.html#memory-allocation",
    "title": "Writing functions in R",
    "section": "Memory allocation",
    "text": "Memory allocation\nPre-allocating memory is faster than growing objects repeatedly.\n\nAssume, we have recorded the results of 1,000 dice rolls:\n\ndata &lt;- sample.int(6, n = 100, replace = TRUE)\n\n\n\nNow, we want to check which ones show “6”. Compare these two approaches:\n\n\n\nis_six_1 &lt;- function(x) {\n  res &lt;- NULL\n  for (i in seq_along(x)) {\n    res[i] &lt;- x[i] == 6\n  }\n  res\n}\n\n\n\nis_six_2  &lt;- function(x) {\n  res &lt;- rep(NA,length(x))\n  for (i in seq_along(x)) {\n    res[i] &lt;- x[i] == 6\n  }\n  res\n}"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#memory-allocation-1",
    "href": "files/Session-4-Functions/functions.html#memory-allocation-1",
    "title": "Writing functions in R",
    "section": "Memory allocation",
    "text": "Memory allocation\nLet’s check which approach is faster:\n\nmicrobenchmark::microbenchmark(is_six_1(data),\n                               is_six_2(data), times = 1000)\n\nUnit: microseconds\n           expr min  lq   mean median  uq    max neval\n is_six_1(data) 1.8 1.9 5.1027    2.0 2.2 2709.5  1000\n is_six_2(data) 1.1 1.3 4.0414    1.3 1.5 2489.1  1000\n\n\n\n\nis_six_2() is faster, as R doesn’t have to grow the res object in every iteration."
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#vectorisation",
    "href": "files/Session-4-Functions/functions.html#vectorisation",
    "title": "Writing functions in R",
    "section": "Vectorisation",
    "text": "Vectorisation\nR has many functions that are vectorised. \n\nInstead of running a loop to check each value of our dice rolls, we can check them all at once by taking advantage of the ability of == to take vector input:\n\n\n\nis_six_2  &lt;- function(x) {\n  res &lt;- rep(NA,length(x))\n  for (i in seq_along(x)) {\n    res[i] &lt;- x[i] == 6\n  }\n  res\n}\n\n\n\nis_six_3 &lt;- function(x) {\n  x == 6\n}"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#vectorisation-1",
    "href": "files/Session-4-Functions/functions.html#vectorisation-1",
    "title": "Writing functions in R",
    "section": "Vectorisation",
    "text": "Vectorisation\n\nmicrobenchmark::microbenchmark(is_six_2(data), \n                               is_six_3(data), times = 1000)\n\nUnit: nanoseconds\n           expr  min   lq   mean median   uq     max neval\n is_six_2(data) 1200 1300 5947.8   1400 1500 4468700  1000\n is_six_3(data)  200  300 1392.5    400  400  985400  1000\n\n\n\nThe vectorised version is_six_3() is much faster."
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#vectorisation-2",
    "href": "files/Session-4-Functions/functions.html#vectorisation-2",
    "title": "Writing functions in R",
    "section": "Vectorisation",
    "text": "Vectorisation\nVectorised matrix functions like rowSums(), colSums() or rowMeans()can lead to impressive speedups:\n\n\ndata &lt;- matrix(rnorm(10^4), nrow = 100)\n\nmicrobenchmark::microbenchmark(\n  apply(data, 2, sum),\n  colSums(data),\n  times = 1000)\n\nUnit: microseconds\n                expr   min    lq     mean median     uq     max neval\n apply(data, 2, sum) 183.2 213.7 349.9197 282.55 350.65 16322.6  1000\n       colSums(data)   8.7   9.4  12.6065  10.10  13.50   193.3  1000"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#rcpp",
    "href": "files/Session-4-Functions/functions.html#rcpp",
    "title": "Writing functions in R",
    "section": "Rcpp",
    "text": "Rcpp\nThe Rcpp package allows for integrating C++ code with R, which can make R functions a lot faster. It requires the installation of a C++ compiler (R tools for Windows, Xcode for Mac, possibly “sudo apt-get install r-base-dev” on Linux)\n\n\nRead more at Rcpp: Seamless R and C++ Integration or Avanced R\n\n\n\nI also highly recommend ChatGpt for help with creating C++ functions."
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#rcpp-1",
    "href": "files/Session-4-Functions/functions.html#rcpp-1",
    "title": "Writing functions in R",
    "section": "Rcpp",
    "text": "Rcpp\nAs an example, let’s compare a random walk implemented in R with one implemented with Rcpp.\n\nFirst, the R version:\n\nrandom_walk_R &lt;- function(steps) {\n  walk &lt;- numeric(steps)\n  for (i in 2:steps) {\n    walk[i] &lt;- walk[i-1] + ifelse(runif(1) &gt; 0.5, 1, -1)\n  }\n  return(walk)\n}"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#rcpp-2",
    "href": "files/Session-4-Functions/functions.html#rcpp-2",
    "title": "Writing functions in R",
    "section": "Rcpp",
    "text": "Rcpp\nNext, the Rcpp version:\n\nlibrary(Rcpp)\nsourceCpp(\n'#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericVector random_walk_Rcpp(int steps) {\n  NumericVector walk(steps);\n  for(int i = 1; i &lt; steps; i++) {\n    walk[i] = walk[i-1] + (R::runif(0, 1) &gt; 0.5 ? 1 : -1);\n  }\n  return walk;\n}')\n\n\nWe now have the function random_walk_Rcpp in the global environment."
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#rcpp-3",
    "href": "files/Session-4-Functions/functions.html#rcpp-3",
    "title": "Writing functions in R",
    "section": "Rcpp",
    "text": "Rcpp\nLet’s make sure both versions work:\n\nplot(random_walk_R(1000), type = \"l\", ylim = c(-50,50))\npoints(random_walk_Rcpp(1000),type = \"l\", col = \"red\")"
  },
  {
    "objectID": "files/Session-4-Functions/functions.html#rcpp-4",
    "href": "files/Session-4-Functions/functions.html#rcpp-4",
    "title": "Writing functions in R",
    "section": "Rcpp",
    "text": "Rcpp\nNow let us compare the speed:\n\nmicrobenchmark::microbenchmark(\n  random_walk_R(1000),\n  random_walk_Rcpp(1000),\n  times = 100)\n\n\n\n\nLoops are much faster in C++!"
  },
  {
    "objectID": "getting-here.html",
    "href": "getting-here.html",
    "title": "Getting here",
    "section": "",
    "text": "Getting here\nThe workshop takes place in Durham’s historic city centre, 20 minutes’ walk from the train station. Sessions will be held in the Tristram Room at St. John’s college: \nDurham can be reached by train in three hours from London, and two hours from Manchester or Edinburgh. The nearest airport is Newcastle Airport, which can be reached by public transport from Durham in one hour. Participants coming by car should contact us so we can arrange parking spaces with Durham University.",
    "crumbs": [
      "Logistics",
      "Getting here"
    ]
  },
  {
    "objectID": "introduction-to-R.html",
    "href": "introduction-to-R.html",
    "title": "Day 1 - Introduction to R",
    "section": "",
    "text": "The files are hosted on the StratoBayes.github.io Github repository. Download them by following the links below, which will lead you to the Github page where the file is hosted. To start the download, click on the downward facing arrow, or click on the three dots (...) in the top right corner, and select Download.",
    "crumbs": [
      "Workshop material",
      "Day 1 - Introduction to R"
    ]
  },
  {
    "objectID": "introduction-to-R.html#session-1---introduction-to-r-and-rstudio",
    "href": "introduction-to-R.html#session-1---introduction-to-r-and-rstudio",
    "title": "Day 1 - Introduction to R",
    "section": "Session 1 - Introduction to R and RStudio",
    "text": "Session 1 - Introduction to R and RStudio\nWorksheet for Session 1",
    "crumbs": [
      "Workshop material",
      "Day 1 - Introduction to R"
    ]
  },
  {
    "objectID": "introduction-to-R.html#session-2---handling-data-import-and-manipulation",
    "href": "introduction-to-R.html#session-2---handling-data-import-and-manipulation",
    "title": "Day 1 - Introduction to R",
    "section": "Session 2 - Handling data: import and manipulation",
    "text": "Session 2 - Handling data: import and manipulation\nWorksheet for Session 2",
    "crumbs": [
      "Workshop material",
      "Day 1 - Introduction to R"
    ]
  },
  {
    "objectID": "introduction-to-R.html#session-3---visualising-and-describing-data",
    "href": "introduction-to-R.html#session-3---visualising-and-describing-data",
    "title": "Day 1 - Introduction to R",
    "section": "Session 3 - Visualising and describing data",
    "text": "Session 3 - Visualising and describing data\nWorksheet for Session 3",
    "crumbs": [
      "Workshop material",
      "Day 1 - Introduction to R"
    ]
  },
  {
    "objectID": "introduction-to-R.html#session-4---writing-functions-in-r",
    "href": "introduction-to-R.html#session-4---writing-functions-in-r",
    "title": "Day 1 - Introduction to R",
    "section": "Session 4 - Writing functions in R",
    "text": "Session 4 - Writing functions in R\nWorksheet for Session 4 The worksheet is the file Session 4 Functions.html.",
    "crumbs": [
      "Workshop material",
      "Day 1 - Introduction to R"
    ]
  },
  {
    "objectID": "introduction-to-R.html#data-and-r-scripts",
    "href": "introduction-to-R.html#data-and-r-scripts",
    "title": "Day 1 - Introduction to R",
    "section": "Data and R scripts",
    "text": "Data and R scripts\nThe data and R scripts for the sessions are found here: Data and R scripts",
    "crumbs": [
      "Workshop material",
      "Day 1 - Introduction to R"
    ]
  },
  {
    "objectID": "organising-team.html",
    "href": "organising-team.html",
    "title": "Organising Team",
    "section": "",
    "text": "This workshop is an outcome of the Leverhulme grant A fizzle or a bang: how fast was the Cambrian ‘explosion’?, awarded to Martin Smith.\n\n\n\n  \n    \n    \n    \n        Kilian Eichenseer\n        Durham University\n    \n\n\n\n  \n    \n    \n    \n        Martin Smith\n        Durham University\n        \n    \n\n\n\n\n\n\n  \n    \n    \n    \n        Matthias Sinnesael\n        Trinity College Dublin\n    \n\n\n\n  \n    \n    \n    \n        Andrew Millard\n        Durham University",
    "crumbs": [
      "Overview",
      "Organising Team"
    ]
  },
  {
    "objectID": "sign-up.html",
    "href": "sign-up.html",
    "title": "Sign-up",
    "section": "",
    "text": "Sign-up\nSign-up for the workshop has now closed.\n\nWe have emailed payment details and confirmation messages to all registered participants.\nIn preparation for the workshop, it would be helpful to install a recent version of R (https://www.r-project.org/) and Rstudio (RStudio Desktop - Posit). Typing the following command into the R console will install the packages necessary to run StratoBayes on day 2:\ninstall.packages(c(\"cli\", \"coda\", \"doParallel\", \"EnvStats\", \"fda\",\n                   \"foreach\", \"dbscan\", \"mcmcse\", \"msm\", \"mvnfast\",\n                   \"protoclust\", \"Rcpp\", \"Rdpack\", \"Rfast\"))",
    "crumbs": [
      "Overview",
      "Sign-up"
    ]
  }
]